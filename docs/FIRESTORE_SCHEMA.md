# RealGram - Firestore Database Schema

## Overview
Production-ready Firestore schema for RealGram real estate social app with all required collections and field structures.

---

## COLLECTIONS

### 1. `users` - User Profiles
**Purpose**: Store all user data for buyers, agents, builders, and admins.

```
Document ID: <uid> (Firebase Auth UID)

{
  "uid": string,
  "role": string,              // "buyer", "agent", "builder", "admin"
  "name": string,
  "phone": string,             // Unique
  "email": string,             // Unique
  "city": string,
  "state": string,
  "country": string,
  "latitude": number,          // User's default location
  "longitude": number,
  "verified": boolean,         // Admin verified
  "subscriptionType": string,  // "free", "premium", "agent_pro"
  "subscriptionExpiry": timestamp,
  "createdAt": timestamp,
  "profileImageUrl": string,   // Firebase Storage URL
  "totalListings": number,     // For agents
  "totalLeads": number,        // For agents
  "avgRating": number,         // 0-5 stars
  "isActive": boolean
}
```

**Indexes**:
- `role` (Ascending)
- `verified` (Ascending)
- `city` (Ascending)
- `createdAt` (Descending)

---

### 2. `properties` - Property Listings
**Purpose**: Store all property data with geo-location.

```
Document ID: <auto-generated>

{
  "ownerId": string,           // Reference to users.uid
  "title": string,
  "description": string,
  "price": number,
  "propertyType": string,      // "plot", "apartment", "house", "commercial"
  "latitude": number,
  "longitude": number,
  "geohash": string,           // Computed from lat/lng
  "imageUrls": [string],       // Array of Firebase Storage URLs
  "videoUrl": string,          // Optional Firebase Storage URL
  "status": string,            // "pending", "approved", "rejected"
  "boostLevel": number,        // 0-5 (premium feature)
  "featured": boolean,
  "views": number,             // Auto incremented
  "favorites": number,
  "createdAt": timestamp,
  "approvedAt": timestamp,     // When admin approved
  "areaUnit": string,          // "sqft" or "sqm"
  "area": number,              // Plot size
  "propertyAddress": string,
  "amenities": [string],       // ["parking", "gym", "pool"]
  "verified": boolean
}
```

**Indexes**:
- `status` (Ascending), `createdAt` (Descending)
- `geohash` (Ascending), `createdAt` (Descending)
- `ownerId` (Ascending), `createdAt` (Descending)
- `boostLevel` (Descending), `views` (Descending)
- `featured` (Ascending), `createdAt` (Descending)
- `propertyType` (Ascending), `price` (Ascending)

---

### 3. `chats` - Chat Rooms
**Purpose**: Store chat metadata between buyer and agent.

```
Document ID: <auto-generated>

{
  "propertyId": string,        // Reference to properties
  "buyerId": string,           // Reference to users.uid
  "agentId": string,           // Reference to users.uid
  "lastMessageTime": timestamp,
  "lastMessage": string,
  "unreadCount": number,
  "isArchived": boolean,
  "createdAt": timestamp
}

Sub-collection: `messages`
Document ID: <auto-generated>

{
  "chatId": string,
  "senderId": string,          // Reference to users.uid
  "text": string,
  "timestamp": timestamp,
  "isRead": boolean,
  "imageUrl": string,          // Optional
  "videoUrl": string           // Optional
}
```

**Indexes**:
- `chats`: `buyerId` (Ascending), `lastMessageTime` (Descending)
- `messages`: `timestamp` (Ascending)

---

### 4. `messages` - Alternative Structure (Flat)
**Optional**: If using flat structure instead of subcollection.

```
Document ID: <auto-generated>

{
  "chatId": string,
  "senderId": string,
  "receiverId": string,
  "text": string,
  "timestamp": timestamp,
  "isRead": boolean,
  "imageUrl": string,
  "videoUrl": string
}
```

---

### 5. `leads` - Sales Leads
**Purpose**: Track buyer interest and agent follow-ups.

```
Document ID: <auto-generated>

{
  "propertyId": string,        // Reference to properties
  "buyerId": string,           // Reference to users.uid
  "agentId": string,           // Reference to users.uid
  "status": string,            // "new", "contacted", "visited", "interested", "rejected", "closed"
  "createdAt": timestamp,
  "contactedAt": timestamp,    // When agent first contacted
  "notes": string,             // Agent notes
  "leadSource": string         // "contact_button", "chat_started", "schedule_visit"
}
```

**Indexes**:
- `agentId` (Ascending), `createdAt` (Descending)
- `propertyId` (Ascending), `status` (Ascending)
- `status` (Ascending), `createdAt` (Descending)

---

## SECURITY RULES

```firestore
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users - Public read, own write
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth.uid == userId;
    }

    // Properties - Public read (approved), owner write, admin delete
    match /properties/{propertyId} {
      allow read: if resource.data.status == "approved";
      allow create: if request.auth != null;
      allow update, delete: if request.auth.uid == resource.data.ownerId;
    }

    // Chats - Participants only
    match /chats/{chatId} {
      allow read: if request.auth.uid == resource.data.buyerId || 
                     request.auth.uid == resource.data.agentId;
      allow create: if request.auth != null;
      allow update: if request.auth.uid == resource.data.buyerId || 
                       request.auth.uid == resource.data.agentId;
    }

    // Messages - Participants only
    match /chats/{chatId}/messages/{messageId} {
      allow read: if request.auth.uid == get(/databases/$(database)/documents/chats/$(chatId)).data.buyerId ||
                     request.auth.uid == get(/databases/$(database)/documents/chats/$(chatId)).data.agentId;
      allow create: if request.auth != null;
    }

    // Leads - Agent & Admin only
    match /leads/{leadId} {
      allow read: if request.auth.uid == resource.data.agentId;
      allow write: if request.auth.uid == resource.data.agentId;
    }
  }
}
```

---

## GEOHASHING FOR GEO-QUERIES

Use `geohash` package to generate location-based hashes.

Example:
```
latitude: 28.6139
longitude: 77.2090 (Delhi)
geohash: "ttnfjfk" (precision 7)
```

**Proximity Search**: Query where geohash starts with "ttnf" for all properties within ~5km radius.

---

## INITIAL SEED DATA

### Admin User
```json
{
  "uid": "admin123",
  "role": "admin",
  "name": "Admin RealGram",
  "email": "admin@realgram.com",
  "verified": true,
  "createdAt": "2025-01-01T00:00:00Z"
}
```

### Test Agent
```json
{
  "uid": "agent123",
  "role": "agent",
  "name": "Test Agent",
  "phone": "+91-98XXXXXX00",
  "city": "Delhi",
  "verified": true,
  "subscriptionType": "agent_pro",
  "createdAt": "2025-01-01T12:00:00Z"
}
```

---

## USAGE PATTERNS

### Pattern 1: Get Nearby Properties
```
Query: properties where geohash >= "ttnf" AND geohash < "ttnfz"
OrderBy: createdAt DESC
Limit: 20
```

### Pattern 2: Get User's Listings
```
Query: properties where ownerId == "agent123"
OrderBy: createdAt DESC
```

### Pattern 3: Get Agent's Leads
```
Query: leads where agentId == "agent123"
OrderBy: createdAt DESC
```

### Pattern 4: Realtime Chat Messages
```
Query: chats/{chatId}/messages
OrderBy: timestamp ASC
Listen: onSnapshot()
```

---

## COST OPTIMIZATION

- Use `limit()` on all queries (default 20)
- Denormalize critical data (e.g., userName in messages)
- Archive old chats
- Use Cloud Functions to auto-delete older than 90 days
- Batch operations where possible

---

## MIGRATION NOTES

1. Start with one city → Expand regions
2. Initial 200 listings → Grow organically
3. Monitor Firestore read/write costs
4. Backup collections monthly using Firestore export
